algorithm
=========

The useful algorithms pratice in ruby

1. __青蛙跳级问题__

  一只青蛙一次可以跳跃1个台阶， 也可以跳跃2个台阶.  求解这只青蛙跳上n个台阶共有多少中方法

2. __获取一个整数二进制表示中1的个数__
  1. 统计整数二进制表示的长度设为length，设有一个标志数flag=1
  2. 然后n与flag的二进制 进行与(&)运算，如果为 1 则 统计个数加1，
  3. 然后将flag向左位移一位
  4. 执行2，3步骤length次

3. __在时间复杂度为O(1)的情况下删除链表指定节点__
  1. 把待删除节点下一个节点内容复制到待删除节点.
  2. 然后把待删除节点向下指针指向下一个节点的下一个节点.

4. __斐波那锲数列__
  - 递归版
  - 循环版
  - 栈版

5. __用两个栈来模拟队列__
  1. 进队列时， 把元素压入进队列辅助栈 @enq_stack
  2. 第一次出队列时候， 为了达到 “先进先出” 的顺序， 把进队列辅助栈中的元素全部压入出队列辅助栈，弹出出队列辅助栈顶元素
  3. 再次出队列时， 如果出队列辅助栈非空， 直接弹出出队列辅助栈顶元素接口，否则重复步骤2中的操作

6. __用两个队列模拟栈__
  - 进栈时， 直接进入进栈辅助队列@push_queue即可
  - 出栈时:
    1. 如果进栈辅助队列只有一个元素， 直接出队列即可
    2. 如果进栈辅助队列不止一个元素， 假设n个（n>1）， 先把队列前面n-1 个元素弹出进栈辅助队列， 然后压入出栈辅助队列， 然后剩下进栈辅助队列中一个元素， 直接出来即可。
    3. 如果进栈辅助队列为空，首先看出栈辅助队列是否有元素，如果有，把它们全部弄进进栈辅助队列，然后重复上面1、2两步如果没得， 则直接返回 nil

7. __选择排序__

  首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。
  以此类推，直到所有元素均排序完毕。
8. __冒泡排序__

  它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，
  越小的元素会经由交换慢慢"浮"到数列的顶端，像<b>冒泡</b>样。
9. __快速排序__
   1. 从列表中任意选择一个数作为基数
   2. 让列表中剩下的元素与基数作比较，小于它的放在一边令其为a1， 大于它的放在另外一边令其为a2
   3. 分别在a1和a2中重复执行第1和第2步，直到只剩一个元素
   4. 把上面所得连接起来
10. __插入排序__
   1. 从第一个元素开始，该元素可以认为已经被排序
   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
   3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
   4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
   5. 将新元素插入到该位置中
   6. 重复步骤2
11. __汉诺塔问题__
   - 递归版
   - 非递归版
12. __树__
   - 根据先序遍历和中序遍历结果创建二叉树
   - 先/中/后序的递归和非递归遍历
   - 在终端打印一颗树
