algorithm
=========

The useful algorithms pratice in ruby

1. __青蛙跳级问题__

  一只青蛙一次可以跳跃1个台阶， 也可以跳跃2个台阶.  求解这只青蛙跳上n个台阶共有多少中方法

2. __获取一个整数二进制表示中1的个数__
  1. 统计整数二进制表示的长度设为length，设有一个标志数flag=1
  2. 然后n与flag的二进制 进行与(&)运算，如果为 1 则 统计个数加1，
  3. 然后将flag向左位移一位
  4. 执行2，3步骤length次

3. __在时间复杂度为O(1)的情况下删除链表指定节点__
  1. 把待删除节点下一个节点内容复制到待删除节点.
  2. 然后把待删除节点向下指针指向下一个节点的下一个节点.

4. __斐波那锲数列__
  - 递归版
  - 循环版
  - 栈版

5. __用两个栈来模拟队列__
  1. 进队列时， 把元素压入进队列辅助栈 @enq_stack
  2. 第一次出队列时候， 为了达到 “先进先出” 的顺序， 把进队列辅助栈中的元素全部压入出队列辅助栈，弹出出队列辅助栈顶元素
  3. 再次出队列时， 如果出队列辅助栈非空， 直接弹出出队列辅助栈顶元素接口，否则重复步骤2中的操作

6. __用两个队列模拟栈__
  - 进栈时， 直接进入进栈辅助队列@push_queue即可
  - 出栈时:
      1. 如果进栈辅助队列只有一个元素， 直接出队列即可
      2. 如果进栈辅助队列不止一个元素， 假设n个（n>1）， 先把队列前面n-1 个元素弹出进栈辅助队列， 然后压入出栈辅助队列， 然后剩下进栈辅助队列中一个元素， 直接出来即可。
      3. 如果进栈辅助队列为空，首先看出栈辅助队列是否有元素，如果有，把它们全部弄进进栈辅助队列，然后重复上面1、2两步如果没得， 则直接返回 nil

7. __选择排序__

  首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。
  以此类推，直到所有元素均排序完毕。
8. __冒泡排序__

  它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，
  越小的元素会经由交换慢慢"浮"到数列的顶端，像<b>冒泡</b>样。
9. __快速排序__
   1. 从列表中任意选择一个数作为基数
   2. 让列表中剩下的元素与基数作比较，小于它的放在一边令其为a1， 大于它的放在另外一边令其为a2
   3. 分别在a1和a2中重复执行第1和第2步，直到只剩一个元素
   4. 把上面所得连接起来
10. __插入排序__
   1. 从第一个元素开始，该元素可以认为已经被排序
   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
   3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
   4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
   5. 将新元素插入到该位置中
   6. 重复步骤2
11. __汉诺塔问题__
   - 递归版
   - 非递归版
12. __树__
   - 根据先序遍历和中序遍历结果创建二叉树
   - 先/中/后序的递归和非递归遍历
   - 在终端打印一颗树
13. __在时间复杂度为O(1)的情况下删除链表指定节点__

  假设有一个单向链表和一个待删除的节点 p ，传统的删除该节点的方法是：首先从头开始遍历，找到待删除节点的前一个节点 pre ，
  然后把 pre 的 next 指针指向   p 的下一个节点。此时的时间复杂度为O(n).
  新思路如下：

   1. 把待删除节点 p 的下一个节点 _nex 内容复制到待删除节点 p.
   2. 然后把待删除节点 p 向下指针指向下一个节点 _next 的下一个节点.

14. __在只遍历一次的条件返回单向链表的倒数第 k 个节点__

  假设一个单向链表从头开始它们的值分别为1，2，3，4，5，6。 那么它们的倒数第 3 个节点值应该是 4。
  **传统方法是**：第一次遍历获取链表的长度 n，第二次指针从前向后移动 n-k+1次，此时指针指向节点就是我们所求节点。
  **新思路如下:**
   1. 先让第一个指针 p1 从前向后走 k-1 步, 此时第二个指针 p2 保持不动
   2. 从第 k 步开始，两个指针同时移动，直到 p1 到达链表的尾节点时，此时 p2 所指节点即为所求。

15. __合并两个排序数组使合并后的数组仍然为排序数组__
   - 如果两个输入数组都为 nil， 则抛出异常
   - 如果其中一个输入数组为 nil， 则返回另外一个数组
   - 如果两个数组都有效：
     - 取出两个数组的第一个数字，按照递增的顺序加入 result 数组， 直至其中最小输入数组为空
     - 把剩下的数组追加到 result 数组上
