# -*- coding: utf-8 -*-
require 'pry'
class Sort
  # === 选择排序
  # 首先在未排序序列中找到最小元素，存放到排序序列的起始位置，
  # 然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。
  # 以此类推，直到所有元素均排序完毕。
  def select_sort(a)
    for i in 0..(a.size-2)
      mini_pos = i
      for j in (i+1)..(a.size-1)
        mini_pos = j if a[mini_pos] > a[j]
      end
      temp = a[i]
      a[i] = a[mini_pos]
      a[mini_pos] = temp
    end
    return a
  end

  # === 冒泡排序
  # 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
  # 走访数列的工作是重复地进行直到没有再需要交换，
  # 越小的元素会经由交换慢慢"浮"到数列的顶端，像<b>冒泡</b>样。
  #
  # 步骤::
  # - 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。
  # - 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
  # - 3.针对所有的元素重复以上的步骤，除了最后一个。
  # - 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
  def bubble_sort(a)
    for i in 0..(a.size-2)
      for j in (i+1)..(a.size-1)
        if a[i] > a[j]
          temp = a[i]
          a[i] = a[j]
          a[j] = temp
        end
      end
    end
    return a
  end

  # === 快速排序
  # - 1.从列表中任意选择一个数作为基数
  # - 2.让列表中剩下的元素与基数作比较，
  # 小于它的放在一边令其为a1， 大于它的放在另外一边令其为a2
  # - 3.分别在a1和a2中重复执行第1和第2步，直到只剩一个元素
  # - 4.把上面所得连接起来
  def quick_sort(a)
    return a if a.size <= 1  # 当a为空数组或是一个元素时直接返回
    middle_pos = (a.size)/2
    a1, a2 = [], []
    for i in 0..(a.size-1)
      # 把小于或等于选取元素的元素(但是排除选取的元素)，追加到 a1中
      if a[i] < a[middle_pos] || (i != middle_pos && a[i] == a[middle_pos])
        a1 << a[i]
      elsif a[i] > a[middle_pos]
        a2 << a[i]
      end
    end
    quick_sort(a1) + [a[middle_pos]] + quick_sort(a2)  # 递归调用
  end

  # === 插入排序
  # 步骤::
  # - 1.从第一个元素开始，该元素可以认为已经被排序
  # - 2.取出下一个元素，在已经排序的元素序列中从后向前扫描
  # - 3.如果该元素（已排序）大于新元素，将该元素移到下一位置
  # - 4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
  # - 5.将新元素插入到该位置中
  # - 6.重复步骤2
  def insert_sort(a)
    for i in 1..(a.size-1)
      to_insert = a[i]
      to_insert_pos = i
      ((i-1).downto(0)).each do |j|
        if to_insert < a[j]
          a[j+1] = a[j]
          to_insert_pos -= 1
        end
      end
      a[to_insert_pos] = to_insert
    end
    return a
  end

  # === 希尔排序
  # 希尔排序是插入排序的改进版，在数据量大的时候对效率的提升帮助很大，
  # 数据量小的时候建议直接使用插入排序就好了。
  #
  # 希尔排序的诞生是由于插入排序在处理大规模数组的时候会遇到需要移动太多元素的问题。
  # 希尔排序的思想是将一个大的数组“分而治之”，划分为若干个小的数组，以 gap（增量） 来划分，
  # 比如数组 [1, 2, 3, 4, 5, 6, 7, 8] ，如果以 gap = 2 来划分，
  # 可以分为 [1, 3, 5, 7] 和 [2, 4, 6, 8] 两个数组
  # （对应的，如 gap = 3 ，则划分的数组为： [1, 4, 7] 、 [2, 5, 8] 、 [3, 6])
  # 然后分别对划分出来的数组进行插入排序，待各个子数组排序完毕之后再减小 gap 值重复进行之前的步骤，
  # 直至 gap = 1，即对整个数组进行插入排序，此时的数组已经基本上快排好序了，所以需要移动的元素会很小很小，
  # 解决了插入排序在处理大规模数组时较多移动次数的问题。
  #
  def shell_sort(a)
    # todo ...
  end
end
